
<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>Herp Derp</title>

    <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.3.1/gl-matrix-min.js"></script>
    <script src="Framework/class.js"></script>
    <script src="Framework/g3dj.js"></script>
    <script src="Framework/entity.js"></script>
    <script src="Framework/animation.js"></script>
    <script src="Framework/bone.js"></script>
    <script src="Framework/inputHandler.js"></script>
    <script src="Framework/pose.js"></script>
    <script src="Framework/mesh.js"></script>
    <script src="Framework/grass.js"></script>
    <script src="Framework/shader.js"></script>
    <script src="Framework/renderManager.js"></script>
    <script src="Framework/heightmap.js"></script>
    <script src="Framework/behavior.js"></script>
    <script src="Models/male.g3dj"></script>
    <script src="Models/helicopter.g3dj"></script>
    <script src="Models/anim.g3dj"></script>
  
</head>
<body style="margin:0">
    <canvas id="canvas" style="position:absolute;"></canvas>
    <div id="containerDiv" align="center" style="position:absolute">
        <div id ="fps"></div>
        <input type="range" id="lightValue" value="50"><br>
        Time of Day
    </div>

<script type='text/javascript'>//<![CDATA[
Math.clamp = function(v, min, max) { return Math.max(min, Math.min(max, v)); }
var canvas = document.getElementById("canvas");
var gl = canvas.getContext("experimental-webgl");

gl.clearColor(0.0, 0.0, 0.0, 1.0);  // Clear to black, fully opaque
gl.clearDepth(1.0);                 // Clear everything
gl.enable(gl.DEPTH_TEST);           // Enable depth testing
gl.depthFunc(gl.LEQUAL);            // Near things obscure far things
gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

Shaders = {
    diffuse: CreateShader("Shaders/diffuse"),
    skinned: CreateShader("Shaders/skinned"),
    grass: CreateShader("Shaders/grass"),
    multitexture: CreateShader("Shaders/multitexture")
}

var projection = mat4.create();
var renderManager = new RenderManager(canvas, canvas.width, canvas.height);
function resizeCallback() {
    canvas.width = document.documentElement.clientWidth;
    $("#containerDiv").width(canvas.width);
    canvas.height = document.documentElement.clientHeight;
    renderManager.width = canvas.width;
    renderManager.height = canvas.height;
    projection = mat4.perspective(projection, Math.PI/2, canvas.width / canvas.height, 0.1, 1000);
    gl.viewport(0, 0, canvas.width, canvas.height);
}
resizeCallback();
$(window).resize(function() {
    resizeCallback();
})

initMouseHandling($("#canvas"));

var dude = new Entity();

var mesh = new Mesh(G3DJToMesh(Models.male), Shaders.skinned);
dude.addComponent(mesh);
dude.Mesh.loadTexture("diffuse", "Models/Dude Suit.png");
dude.addComponent(new Behavior({animation: "Default", pause: 2, target: vec3.create()}, function(dt) {
    var moveSpeed = 0.05;
    var move = vec3.create();
    var position = vec3.clone(this.entity.Pose.position);
    position[1] = 0;
    this.pause -= dt;
    if(this.pause <= 0) {
        vec3.random(this.target, 5);
        this.target[1] = 0;
        this.pause = 2;
    }

    vec3.subtract(move, this.target, position)
    if(vec3.sqrLen(move) < dt * moveSpeed) {
        this.animation = "Default"
        vec3.copy(position, this.target);
    }
    else {
        this.animation = "Run";
        vec3.normalize(move, move);
        vec3.scale(move, move, moveSpeed);
        vec3.add(this.entity.Pose.position, position, move);
        this.entity.Pose.face(move);
        this.entity.Pose.position[1] = terrain.Heightmap.surfaceAt(this.entity.Pose.position[0], this.entity.Pose.position[2]);
    }

    var anim = this.entity.Animation;
    if(!anim.currentClip || anim.currentClip.name != this.animation) {
        anim.stop();
        anim.play(this.animation);
    }
}));

var skeleton = G3DJToSkeleton(Models.male);
dude.addComponent(skeleton);
var animation = G3DJToAnimation(Models.anim);
dude.addComponent(animation);
dude.addComponent(new Pose());
quat.rotateX(dude.Pose.rotation, dude.Pose.rotation, -Math.PI / 2);

var helicopter = new Entity();
helicopter.addComponent(new Pose());
quat.rotateX(helicopter.Pose.rotation, helicopter.Pose.rotation, -Math.PI / 2);
helicopter.Pose.position[1] = 2;
helicopter.addComponent(new Mesh(G3DJToMesh(Models.helicopter), Shaders.skinned));
helicopter.addComponent(G3DJToSkeleton(Models.helicopter));
animation = G3DJToAnimation(Models.helicopter);
helicopter.addComponent(animation);
animation.play("Spinning");
helicopter.Mesh.loadTexture("diffuse", "Models/Helicopter_Diffuse_Color.png");

var terrain = new Entity();
terrain.addComponent(new Heightmap("Models/Heightmap.png", 30, 2, 256, 256));
terrain.addComponent(new Pose());
terrain.Pose.position[0] = -256;
terrain.Pose.position[2] = -256;

var grass = new Entity();
grass.addComponent(new Grass([
    vec3.fromValues(0,0,0), vec3.fromValues(0,0,7),
    vec3.fromValues(-2,0,3.5), vec3.fromValues(2,0,3.5), vec3.fromValues(6,0,3.5),
    vec3.fromValues(4,0,7), vec3.fromValues(4,0,0)]));
grass.addComponent(new Pose());
grass.Pose.scale[0] = 0.3;
grass.Pose.scale[1] = 1;
grass.Pose.scale[2] = 0.3;

var prev_timestamp = 0;
var cameraPosition = vec3.create();
var cameraLookAt = vec3.create();
var cameraR = 10;
var theta = Math.PI / 4;
var phi = -Math.PI / 8;
var moveSpeed = 5;
var cameraSensitivity = 1;
var moveDir = vec3.create();
var mouseSensitivity = 1 / 300;

var cameraRotation = mat4.create();
var view = mat4.create();
var viewProjection = mat4.create();
var cameraUp = vec3.create();
var forward = vec3.fromValues(0, 1, 0);
var lightAngle = quat.create();
var lightDir = vec3.create();
var averageFPS = 0;
function loop(timestamp) {
    var delta = 0;
    if (prev_timestamp > 0) delta = (timestamp - prev_timestamp) / 1000;
    if(delta > 0)
        averageFPS = averageFPS * 0.85 + (1 / delta * 0.15);
    $("#fps").text("FPS: " + averageFPS.toString().substr(0, 4));

    moveDir = vec3.create();
    if(keyboardState[87]) moveDir[2] -= 1;
    if(keyboardState[83]) moveDir[2] += 1;
    if(keyboardState[68]) moveDir[0] += 1;
    if(keyboardState[65]) moveDir[0] -= 1;
    if(keyboardState[32]) moveDir[1] += 1;
    if(keyboardState[67]) moveDir[1] -= 1;
    cameraR -= mouseState.wheelDelta / 200;
    cameraR = Math.max(1, cameraR);
    if(keyboardState[38]) phi -= cameraSensitivity * delta;
    if(keyboardState[40]) phi += cameraSensitivity * delta;
    if(keyboardState[37]) theta += cameraSensitivity * delta;
    if(keyboardState[39]) theta -= cameraSensitivity * delta;
    if(mouseState.buttons.left) {
        theta -= mouseState.delta[0] * mouseSensitivity;
        phi -= mouseState.delta[1] * mouseSensitivity;
    }

    mat4.identity(cameraRotation);
    mat4.rotateY(cameraRotation, cameraRotation, theta);
    vec3.transformMat4(moveDir, moveDir, cameraRotation);
    vec3.scale(moveDir, moveDir,moveSpeed * delta);
    if(keyboardState[16])
        vec3.scale(moveDir, moveDir, 10);
    vec3.add(cameraLookAt, cameraLookAt, moveDir);
    cameraLookAt[1] = terrain.Heightmap.surfaceAt(cameraLookAt[0], cameraLookAt[2]);
    if(theta > Math.PI * 2) theta -= Math.PI * 2;

    //Camera matrix calculation
    mat4.rotateX(cameraRotation, cameraRotation, phi);
    vec3.set(cameraPosition, 0, 0, cameraR);
    vec3.set(cameraUp, 0, 1, 0);
    vec3.transformMat4(cameraPosition, cameraPosition, cameraRotation);
    vec3.transformMat4(cameraUp, cameraUp, cameraRotation);
    vec3.add(cameraPosition, cameraLookAt, cameraPosition);
    mat4.lookAt(view, cameraPosition, cameraLookAt, cameraUp)

    //Light direction
    quat.identity(lightAngle);

    quat.rotateZ(lightAngle, lightAngle, Number($("#lightValue").val()) / 50 * Math.PI);
    vec3.transformQuat(lightDir, forward, lightAngle);

    Entity.entities.map(function(entity) { entity.update(delta); });
    renderManager.beginDraw(timestamp / 1000.0, lightDir, view, projection, cameraPosition);
    Entity.entities.map(function(entity) { entity.draw(renderManager); });
    prev_timestamp = timestamp;
    updateInputState();
    window.requestAnimationFrame(loop);
}
loop(0);
//]]> 

</script>

</html>

